<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Design & Codice — Tris Minimax (Java)</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>
<div class="wrap">
  <header class="header">
    <div class="logo">TR</div>
    <div class="title">
      <h1>Design & Codice</h1>
      <p class="lead">Spiegazione completa del codice Java del Tris con Minimax</p>
    </div>
    <nav class="nav">
      <a href="index.html">Home</a>
      <a href="design.html" class="active">Design & Codice</a>
    </nav>
  </header>

  <main class="main">

    <section class="card">
      <h2>Classe Board</h2>
      <p>Gestisce la griglia e fornisce metodi per applicare mosse e controllare vittorie.</p>
      <ul>
        <li><code>Board()</code>: crea una griglia vuota 3x3.</li>
        <li><code>Board(Board other)</code>: costruttore di copia; copia manualmente ogni cella usando i getter.</li>
        <li><code>getCell(int r, int c)</code> / <code>setCell(int r, int c, char val)</code>: getter e setter per singola cella.</li>
        <li><code>isFull()</code>: restituisce true se tutte le celle sono occupate.</li>
        <li><code>applyMove(Move move, char player)</code>: applica una mossa se valida, restituisce true se la mossa è stata inserita.</li>
        <li><code>checkWin(char player)</code>: controlla tutte le righe, colonne e diagonali per determinare la vittoria del giocatore.</li>
        <li><code>emptyCellsCount()</code>: restituisce il numero di celle vuote.</li>
        <li><code>isCellEmpty(int r, int c)</code>: controlla se una cella è vuota e se riga/colonna sono valide.</li>
        <li><code>printBoard()</code>: stampa la griglia su console per debug.</li>
      </ul>
    </section>

    <section class="card">
      <h2>Classe Move</h2>
      <p>Rappresenta una mossa con riga e colonna (0..2).</p>
      <ul>
        <li><code>Move(int r, int c)</code>: costruttore base.</li>
        <li>Getter e setter per riga (<code>getRow()/setRow()</code>) e colonna (<code>getCol()/setCol()</code>).</li>
        <li><code>toString()</code>: restituisce una rappresentazione leggibile della mossa (es. "(0,1)").</li>
      </ul>
    </section>

    <section class="card">
      <h2>Classe TreeNode</h2>
      <p>Nodo dell’albero di gioco senza ArrayList, con massimo 9 figli.</p>
      <ul>
        <li><code>Board board</code>: stato della griglia in quel nodo.</li>
        <li><code>char player</code>: giocatore corrente in quel nodo.</li>
        <li><code>TreeNode[] children</code>: array di massimo 9 figli.</li>
        <li><code>numChildren</code>: contatore dei figli aggiunti.</li>
        <li><code>int value</code>: valore Minimax calcolato per il nodo.</li>
        <li><code>Move moveFromParent</code>: mossa che ha portato a questo nodo.</li>
        <li><code>addChild(TreeNode child)</code>: aggiunge un figlio se <code>numChildren &lt; 9</code>.</li>
        <li>Getter e setter per tutte le proprietà.</li>
      </ul>
    </section>

    <section class="card">
      <h2>Classe Tree</h2>
      <p>Costruisce l’albero di gioco e calcola la mossa ottimale tramite Minimax senza ternary operator.</p>
      <ul>
        <li><code>generateChildren(TreeNode node)</code>: crea tutti i figli possibili per il nodo corrente.</li>
        <li><code>evaluate(Board b)</code>: ritorna +1 se X vince, -1 se O vince, 0 altrimenti.</li>
        <li><code>minimax(TreeNode node)</code>: metodo ricorsivo che assegna il valore Minimax a ogni nodo.
            <ul>
              <li>Se il nodo non ha figli, valuta la board con <code>evaluate</code>.</li>
              <li>Altrimenti, cicla su tutti i figli:
                <ul>
                  <li>Se giocatore X: aggiorna <code>bestVal</code> se il figlio ha valore maggiore.</li>
                  <li>Se giocatore O: aggiorna <code>bestVal</code> se il figlio ha valore minore.</li>
                </ul>
              </li>
            </ul>
        </li>
        <li><code>bestMove()</code>: chiama <code>minimax(root)</code> e restituisce la mossa ottimale tra tutti i figli della radice.</li>
        <li><code>computeBestMove(Board b, char player)</code>: metodo statico per ottenere direttamente la migliore mossa dalla board iniziale.</li>
      </ul>
    </section>

    <section class="card">
      <h2>Classe Game (Main)</h2>
      <p>Gestisce il gioco X (utente) vs O (IA) tramite console.</p>
      <ul>
        <li>Crea la board iniziale.</li>
        <li>Chiama <code>Tree.computeBestMove(board,'X')</code> per ottenere la mossa ottimale di X.</li>
        <li>Stampa la board con <code>printBoard()</code>.</li>
        <li>Stampa la mossa scelta o messaggio se non ci sono mosse disponibili.</li>
      </ul>
    </section>

    <section class="card">
      <h2>Note importanti</h2>
      <ul>
        <li>Non si usano ArrayList: tutti i figli sono contenuti in array fissi di dimensione 9.</li>
        <li>Nessun uso dell'operatore ternario (<code>?:</code>); si usano sempre <code>if/else</code>.</li>
        <li>Tutti i cicli <code>for</code> e <code>if</code> usano sempre le parentesi graffe anche se singole istruzioni.</li>
        <li>Minimax calcola ricorsivamente il valore di ogni nodo e determina la mossa ottimale.</li>
      </ul>
    </section>

  </main>

  <footer class="footer">
    <div>Tris & Minimax — Design</div>
    <div class="muted">Wei Chen</div>
  </footer>
</div>
</body>
</html>
